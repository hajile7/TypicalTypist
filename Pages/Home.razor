@using System.Diagnostics
@using TypicalTypist.Models
@using TypicalTypist.Services

@page "/"

@inject WordService wordService
@inject IJSRuntime JSRuntime
@inject UserService userService

@* Start HTML *@

<PageTitle>Home</PageTitle>
<p>Time: @elapsedTime | Speed: @speed | Accuracy: @accuracy</p>

<div class="typing-container">
    <div @ref="textInput"
    tabindex="0"
    @onkeyup="OnInput"
    @onfocus="OnFocus"
    @onblur="OnBlur"
    class="@(!isFocused ? "blurred" : "") no-focus-visible"
    >
    @if (testInstance?.Any() == true && correctStatus.Count > 0)
    {
        @foreach (var tuple in testInstance.Select((word, index) => (word, index)))
        {
            <span class="word">
                @foreach (var tuple2 in tuple.word.Chars.Select((Chars, index) => (Chars, index)))
                {
                    @if ((tuple2.index + tuple.word.StartIndex == currIndex) && isFocused && (correctStatus.Count > tuple2.index + tuple.word.StartIndex))
                    {
                        <span class="cursor"></span>
                    }
                    <span style="display: inline-block;"
                        class="@(tuple2.index + tuple.word.StartIndex < correctStatus.Count
                        ? (correctStatus[tuple2.index + tuple.word.StartIndex] == true ? "correct"
                            : (correctStatus[tuple2.index + tuple.word.StartIndex] == false ? "incorrect" : "neutral"))
                        : "neutral")">
                        @tuple2.Chars
                    </span>
                }
            </span>
            @if (tuple.index < testInstance.Count() - 1)
            {
                <span
                    class="space @(correctStatus[tuple.word.StartIndex + tuple.word.Chars.Count] == true ? "correct" 
                    : (correctStatus[tuple.word.StartIndex + tuple.word.Chars.Count] == false ? "incorrect" : "neutral"))">
                    @if (tuple.word.StartIndex + tuple.word.Chars.Count == currIndex && isFocused)
                    {
                        <span class="cursor"></span>
                    }
                    &#8901;
                </span>
            }
        }
    }
    </div>
    @if(!isFocused){
        <div class="focus-text">
            Click Here or Push Any Key to Focus
        </div>
    }
</div>
<p>
    Prev tests: @foreach(double spd in speedList) {
        <span>@speedList.Count: @spd</span> 
    }
</p>
<p>
    Prev tests: @foreach(double acc in accuracyList) {
        <span>@accuracyList.Count: @acc</span> 
    }
</p>
@if(userService.IsLoggedIn)
{
    <p>
        Welcome, @userService.activeUser.UserName
    </p>
}
@code 
{
    // Variables
    // Word Lists
    private HashSet<char> legalChars = new() {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
                                              'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
                                              '1','2','3','4','5','6','7','8','9', '0', '.', ',', '\'', '"', '?', '!', '*', '=', '+', '-', '/', '\\', '<', 
                                              '>', '(', ')', '{', '}', '[', ']', '^', '~', '%', '$', '#', '@', '`', '&', '|'};    
    private List<WordTestObject> testInstance = new();
    private List<CharChecker> charsTypedList = new();
    private List<char> currTestKey = new();

    // Correct Status
    private List<bool?> correctStatus = new List<bool?>();
    private bool correct = false;

    // Key Counters
    private int includedKeysPressed = 0;
    private int correctKeys = 0;
    private int totalKeysPressed = 0;

    // Timer
    private Stopwatch stopwatch = new Stopwatch();
    private Task? timerTask;
    private CancellationTokenSource? cancellationTokenSource;
    private double accurateTime;
    private int elapsedTime;

    // Calcs
    List<double> accuracyList = [];
    List<double> speedList = [];
    double speed = 0;
    double accuracy = 0;
    double prevAccuracy = 0;
    double prevSpeed = 0;
    double totalAccuracy = 0;
    double totalSpeed = 0;
    int rountCount = 0;

    // Other
    private ElementReference textInput;
    private DotNetObjectReference<Home>? dotNetRef;
    private int currIndex = 0;
    private bool isFocused = true;
    private char userLetter;
    private char currChar;
    private char prevChar;
    private bool backspacePush = false;
    private int backspaceCounter = 0;
    private int backspaceTotalCount = 0;
    private bool isActiveSession = false;
    
    // Lifecycle Methods
    protected override void OnInitialized() 
    {
        JSRuntime.InvokeVoidAsync("scrollTypingContainer");
        dotNetRef = DotNetObjectReference.Create(this);
    }

    protected override async Task OnInitializedAsync()
    {
        // Get first test instance and instantiate our currTestKey var
        testInstance = await wordService.GetRandomWordsTest();

        if(testInstance.Count > 0)
        {
            ProcessCheckTestInstance();
        }

        StateHasChanged();
    } 

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if(firstRender) {
            await JSRuntime.InvokeVoidAsync("addSpacePreventListener");
            await textInput.FocusAsync();
        }
    }

    public void Dispose()
    {
        DisposeAsync().AsTask().GetAwaiter().GetResult();
    }

    // Methods
    // Timer
    private void StartTimer()
    {
        if (!stopwatch.IsRunning)
        {
            stopwatch.Start();
            cancellationTokenSource = new CancellationTokenSource();
            timerTask = UpdateTimerAsync(cancellationTokenSource.Token);
        }
    }

    private async Task UpdateTimerAsync(CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            accurateTime = stopwatch.Elapsed.TotalSeconds;
            elapsedTime = (int)stopwatch.Elapsed.TotalSeconds;

            await InvokeAsync(StateHasChanged);

            await Task.Delay(1000, cancellationToken);
        }
    }

    private void PauseTimer()
    {
        if (stopwatch.IsRunning)
        {
            cancellationTokenSource?.Cancel();
            stopwatch.Stop();
        }
    }

    private void ResumeTimer()
    {
        if (!stopwatch.IsRunning)
        {
            stopwatch.Start();
            cancellationTokenSource = new CancellationTokenSource();
            timerTask = UpdateTimerAsync(cancellationTokenSource.Token);
        }
    }

    private void ResetTimer()
    {
        if(!stopwatch.IsRunning)
        {
            stopwatch.Reset();
        }
    }

    // Handling Focus / Blur
    private async Task OnBlur()
    {
        PauseTimer();
        isFocused = false;
        await JSRuntime.InvokeVoidAsync("addGlobalKeyListener", dotNetRef);
    }

    private async Task OnFocus()
    {
        isFocused = true;
        if(isActiveSession)
        {
            ResumeTimer();
        }
        await JSRuntime.InvokeVoidAsync("removeGlobalKeyListener", dotNetRef);
    }

    [JSInvokable("OnKeyUp")]
    public void OnKeyUp()
    {
        textInput.FocusAsync();
    }

    public async ValueTask DisposeAsync()
    {
        await JSRuntime.InvokeVoidAsync("removeGlobalKeyListener");
        dotNetRef?.Dispose();
    }

    // Handling Input
    private void OnInput(KeyboardEventArgs e)
    {
        Console.WriteLine("Current index: " + currIndex); 
        Console.WriteLine("Current character: " + currChar); 
        StartTimer();
        if(!isActiveSession)
        {
            isActiveSession = true;
        }
        if(backspacePush == true)
        {
            backspacePush = false;
        }

        char lastTypedChar = e.Key.Length == 1 ? e.Key[0] : '\0';
        userLetter = lastTypedChar;

        // Keep count of non-alphabetical characters outside of space, shift, and backspace
        if (e.Key == "Backspace")
        {
            if(currIndex > 0)
            {
                currIndex--;
                backspaceCounter++;
                backspaceTotalCount++;
            }
            correctStatus[currIndex] = null;
            backspacePush = true;
            Console.WriteLine("Current index is: " + currIndex);
        }

        // Handle alphabetical keys & space
        else if(legalChars.Contains(lastTypedChar) || lastTypedChar == ' ')
        {
            includedKeysPressed++;
            Console.WriteLine("IncludedKeysPressed has been incremented to: " + includedKeysPressed);

            if (currIndex < currTestKey.Count - 1)
            {
                currIndex++;
            }

            if (currIndex < correctStatus.Count)
            {
                if (currChar == lastTypedChar)
                {
                    correct = true;
                    correctKeys++;
                    correctStatus[currIndex - 1] = true;
                }
                else
                {
                    correct = false;
                    correctStatus[currIndex - 1] = false;
                }
            }
            includedKeysPressed = includedKeysPressed - backspaceCounter;
            backspaceCounter = 0;
        }
        JSRuntime.InvokeVoidAsync("scrollTypingContainer");
        calcAccuracy();
        if(elapsedTime > 0) {
            calcSpeed();
        }
        GetNextChar();
    }

    private void GetNextChar()
    {
        if(backspacePush)
        {
            currChar = currTestKey[includedKeysPressed - backspaceCounter];
            Console.WriteLine("After the backspace, the new currChar is: " + currChar); 
        }
        else
        {
            if(legalChars.Contains(userLetter) || userLetter == ' ') 
            {
                charsTypedList.Add(new CharChecker{Letter = currChar, Time = accurateTime, Correct = correct, PushedLetter = userLetter});
            }
            prevChar = currChar;
            currChar = currTestKey[includedKeysPressed];
            if(includedKeysPressed == currTestKey.Count - 1)
            {
                PauseTimer();
                ResetTimer();
                accuracyList.Add(accuracy);
                speedList.Add(speed);
                prevAccuracy = accuracy;
                prevSpeed = speed;
                rountCount++;
                StartNewTestInstance();
            }   

        } 
    }

    private async void StartNewTestInstance() 
    {
        calcTotalAccuracy();
        calcTotalSpeed();
        currTestKey = new();
        charsTypedList = new();
        correctStatus = new();
        testInstance = new();
        isActiveSession = false;
        totalKeysPressed = 0;
        includedKeysPressed = 0;
        correctKeys = 0;
        currIndex = 0;
        elapsedTime = 0;
        accurateTime = 0;
        speed = 0;
        accuracy = 0;

        testInstance = await wordService.GetRandomWordsTest();

        if(testInstance.Any())
        {
            ProcessCheckTestInstance();
            StateHasChanged();
        }

    }

    // Calculations
    private void calcAccuracy()
    {
        totalKeysPressed = includedKeysPressed + backspaceTotalCount;
        accuracy = (double)correctKeys / (double)totalKeysPressed;
    }

    private void calcSpeed()
    {
        double elapsedTimeMins = stopwatch.Elapsed.TotalMilliseconds / 1000 / 60;
        speed = (totalKeysPressed / 4.7) / elapsedTimeMins;
    }

    private void calcTotalAccuracy()
    {
        double total = 0;
        foreach(double acc in accuracyList)
        {
            total += acc;
        }
        totalAccuracy = total / accuracyList.Count;
    }

    private void calcTotalSpeed()
    {
        double total = 0;
        foreach(double spd in speedList)
        {
            total += spd;
        }
        totalSpeed = total / speedList.Count;
    }

    private void ProcessCheckTestInstance() 
    {
        int totalLength = 0;

        foreach(WordTestObject testObj in testInstance) 
        {
            foreach(char word in testObj.Chars) 
            {
                currTestKey.Add(word);
                totalLength++;
            }
            currTestKey.Add(' ');
            totalLength++;
        }

        correctStatus = new List<bool?>(Enumerable.Repeat((bool?)null, totalLength));
        currChar = currTestKey[0];

    }

}
